# 2/7

## 一，random模块（python）
### 1,1 随机生成整数
randint(a,b)                       返回[a,b]之间的随机整数
randrange(a,b,step)          返回[a ,b)步长为step的随机整数

1. 思考题1：和range()有什么区别？
回答：range()是python的内置函数，有三种调用方式，用来控制循环次数，返回的是一个左闭右开的Range对象

range的三种调用方式:
range(n)
range(a,b)
range(a,b,step)

 2. 思考题2：随机生成取值边界如何界定？
 回答：range，randrange，random都是左闭右开；randint，uniform都是闭区间
### 1,2 随机生成浮点数
random()                       返回[0.0,1.0)之间的随机浮点数
uniform(a,b)                  返回[a,b]之间的随机浮点数

### 1,3 随机选择序列中的一个元素
choice(seq)                                                 等概率返回一个元素
choices(seq, weights=weights, k=?)          有放回抽样，通过k参数返回多个元素(可能重复)，可通过weights参数控制权重
```python
def choices_demo():
	students = ["hrx","gjw","xxy","zht"]
	# weights权重特点是不需要和为1或100，python会自动处理数据
	# weights必须是浮点数或整数，且必须与列表一直
	weights = [1,1,1,7]   
	for i in range(5):
		print(random.choices(students, weights=weights, k=2))
		time.sleep(0.5)
```

sample(seq, k)                                           无返回抽样，返回的k个列表元素无重复
shuffle(seq)                                               打乱顺序

### 1.4 随机种子
种子是输入给算法的初始数字，只要初始种子相同，在同一算法下，得到的结果也相同。只要在调用random模块函数前设置seed值，那么后续随机的结果就会被固定，所以也叫伪随机
random.seed(10)
```python
#固定序列（循环外）
def seed_demo1():
	random.seed(10)
	for i in range(100):
		print(random.randint(1,7))
		time.sleep(0.5)
		
#固定值（循环内）
def see_demo2():
	for i in range(100):
		random.seed(10)
		print(random.randint(1,7))
		time.sleep(0.5)
```


### 1.5 import和from import
![[Pasted image 20260207145556.png]]

# 2/8

## 题目1 两数之和
### 题目描述：
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。你可以按任意顺序返回答案

### 解法1 暴力求解：
使用双重for循环，i遍历记录第一个数字，j遍历记录第二个数字,if判断两数之和是否等于target。判断成功返回索引，失败返回0
代码如下：
```java
class Solution{
	public int[] twoSum(int [] nums, int target){
		for(int i = 0; i <nums.length; i++){
			for(int j=i+1; j<nums.length; j++){
				if(nums[i] + nums[j] == target){
					return new int []{i,j};
				}
			}
		}
		return new int[0];
	}
}
//时间复杂度为O(n^2)
```

## 题目1 两数之和
### 题目描述：
两数之和，暴力求解在数据繁杂的情况下时间复杂度太高，引入哈希表寻求更优解

### HashMap知识点：
1. HashMap,使用泛型，必须要用包装类（Integer,String等），因为泛型的类型擦除要求必须是Object对象
```java
Set                                                   Map
仅存储单个对象                                          存储键值对
不允许元素重复                                          key不允许重复，value允许

Ps:Set,Map均为接口，ta的实现类HashSet,HashMap均无序
```

2. HashMap具体使用
```java
构造器：
Map<key,value> 哈希表名 = new HashMap<>();//向上转型的写法
//其中，key具有唯一性；不可更改性；且如果value为自己构造的对象，必须重写hashCode(),equal()方法
```

```java
成员方法：
Map<String,String> studentID = new HashMap<>();
1.put() 向表中添加元素
studentId.put("6020221970","hrx");
2.get() 通过key找到value并返回
String value = studentID.get(6020221970"");
3.size() 返回表的大小
注意数组的length不是方法，不用加小括号
4.keySet() 返回Map中所有的Key,返回形式是Set
Set<String> keySet = studentID.keySet();
5.containsKey 判断HashMap是否包含该key
if(hashMap.containsKey(key))
{...}
```

```java
遍历：
通过get方法和keySet方法以及增强for循环（也叫for-each）实现遍历
假设现在已经拥有了一个HashMap，名字为studentID，则遍历代码如下：
Set<String> keySet = studentID.keySet();
for(String key : keySet){
	System.out.println("key:"+key+"\t"+"value:"+studentID.get(key));
}
```

### 解法2 哈希表
```java
import java.util.Map;

class Solution {

    public int[] twoSum(int [] nums, int target) {
        //HashMap<数字，索引>
        Map<Integer,Integer> hashMap = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            int complement = target -nums[i];
            //如果补数在哈希表中就代表找到了两个数，通过哈希表可以直接找到两个数的索引
            if(hashMap.containsKey(complement)){
                return new int[]{hashMap.get(complement),i};
            }
            //如果补数不在哈希表中则添加补数进哈希表，哈希表就是一个关于target的补数表
            hashMap.put(nums[i],i);
        }
        return new int[0];
    }
}
//时间复杂度为O(n),平均情况为O(1)，n/n==1
```

# 2/9
## 一，selenium模块
## 1.1 Options (浏览器配置类)
### 1.1.1 常用函数
1. add_argument("") 
向浏览器添加命令行开关
```python
--headless  无头模式
--no-sandbox  禁用沙盒模式，牺牲安全性换取兼容性
--start-maximized  启动最大化
```
2. add_experimental_option("","") 
添加实验性选项，深度控制浏览器，格式为键值对
```python
("detach",True)  运行脚本结束后不退出浏览器
("excludeSwitches",["enable-automation"])   排除开关，value为列表，这行代码的意思是取消“正受自动测试软件控制”提示
```
## 1.2 webdriver对象
### 1.2.1 常用函数
1. get()  打开网页
2. close()  关闭当前标签页
3. quit()    退出浏览器
4. maximize_window()  最大化
5. minimize_window()  最小化
6. set_window_size()    设置尺寸
7. set_window_position  设置位置
8. refresh()   刷新当前页面
9. get_screenshoot_as_file  浏览器截图

### 1.2.2  元素定位（By）
1. find_element()       定位一个元素并返回一个结果，找不到报错
2. find_elements()      定位多个元素并返回列表，找不到返回空列表，可以通过索引切片从列表中找到指定元素
PS：在浏览器控制台，doucument.getElementByID()可以在控制台定位元素

```python
# 八种定位方式
1,By.ID
2,By.NAME
3,By.CLASS_NAME
4,By.TAG_NAME    标签名
5,By.LINK_TEXT   文本链接
6,By.PARTIAL_LINK_TEXT  模糊文本链接   
7,By.XPATH        路径（浏览器右击复制）
8,By.CSS_SELECTOR

# CSS_SELECTOR定位
find_element(By.CSS_ELEMENT,"#id")        定位id
find_element(By.CSS_ELEMENT,".class")     定位class
find_element(By.CSS_ELEMENT,"不加修饰符")   定位标签名
find_element(By.CSS_ELEMENT,"[xxx = "" ]")  定位任意属性类型
# 其中*=为模糊匹配，^=为开头值,$=为结束值

最通用的定位方式，浏览器控制台右击复制，浏览器会给一个唯一的定位值
```
### 1.2.3  元素交互
1. send_key()   元素输入
2. clink()   元素点击
3. clear()   元素清空

### 1.2.4 隐式等待
driver.implicitly_wait(10)
全局设置，等待元素加载，超时则抛出异常

### 1.2.5 导包
from selenium import webdriver
from selenium.webdriver.edge.service import Service
from selenium.webdriver.edge.options import Options
from.selenium.webdriver.common.by import By

## 二，补充知识点
### 2.1 with
上下文管理器，自动清理，不用手动关闭
### 2.1 json模块
1. json.dump()
 dump为倾倒，将内存中的cookies保存到文件中
```python
# w为写，r为读
with open(path,"w"，encoding="utf-8") as f:
	# 把cookies输出到保存的path路径中(f)
	dump(cookies,f)
```
2. json.load()
```python
with open(path,"r",encoding="utf-8") as f:
	# 将path路径下的文件(f)加载出来转化为python的列表形式
	json.load(f)
```
### 2.3 其他函数
driver.get_cookies()   获取cookies
driver.delete_all_cookies()    删除当前所有cookies（因为游客登录也会有cookie,防止冲突）
driver.add_cookie()     （for in循环可以给浏览器逐个添加cookie）

# 2/10
## 一，selenium模块
### 1.1 句柄
句柄是浏览器标签页的唯一身份证，具有唯一性，动态性（每次打开浏览器句柄都不相同），不可见性（不存在于网页代码）
1. driver.window_handles  获取全部标签页的句柄
```python
# driver此时为用cookies登录的bililbili网页
driver = bili_login_with_cookie()  
time.sleep(1)  
# 在当前浏览器标签页焦点下通过快捷键新建标签页  
mouse.hotkey("ctrl","t")  
mouse.hotkey("ctrl", "t")  
# 获取浏览器全部句柄  
handles = driver.window_handles  
print(handles)
```
2. driver.switch_to.window(handles[i])   切换句柄
```python
# 通过索引切换句柄标签页  
driver.switch_to.window(handles[2])
```
## 二，pyautogui模块
### 2.1 介绍
模拟鼠标对象的库，keyboard则是键盘快捷键的库，演示代码将会用到
### 2.2 常用函数
1. moveTo(x,y,duration)   移动到
2. move(x,y,duration)      偏移
ps: move和moveTo的x,y范围都是左开右闭
3. size()                           获取屏幕分辨率
4. position()                    获取当前鼠标位置
5. click(x,y,clicks)             在（x,y）屏幕处点击clicks次
6. hotkey("win", "d")       快捷键，参数可为多个

```python
# 实时获取当前鼠标位置,且用户按下esc即退出当前程序  
def real_time_monitor():  
    last_position = mouse.position()  
    print(last_position)  
    while True:  
        if keyboard.is_pressed("esc"):  
            print("检测到用户按下esc，正在执行退出")  
            break  
        current_position = mouse.position()  
        # 监测鼠标是否移动，如果移动则进入下一环  
        if current_position != last_position:  
            # 如果鼠标移动则先休眠0.2s,去判断鼠标是否停了下来  
            # 0.1s模拟的是人移动鼠标这个动作的一个大概时间，  
            # 0.1s后鼠标悬停（所以我们最好在0.1s后鼠标不移动,如果移动也没关系，移动中不打印）  
            time.sleep(0.1)  
            check_position = mouse.position()  
            # 相等则检查到鼠标后续停留，没有移动,则打印，如果一直在移动，什么都不干  
            if check_position == current_position:  
                print(current_position)  
                last_position = current_position
```

# 2/11 
问卷星个性化脚本（selenium库具体演示）

# 2/12
## 一，pyautogui模块
### 1.1 常用函数
scroll()      模拟滑轮滚动(需要先用moveTo移动到指定位置）,负数为向下移动
press(“esc”，presses, interval)      按下并释放按键,按键输入
hotkey("","")               组合按键
write(“”，interval)      模拟键盘一个个按下字符键,不支持中文，要输出中文可以切换中文状态下的输入法通过空格
sleep()     调用time.sleep()

ps: 获取窗口焦点(很重要)，不管是press还是hotkey，在调用方法之前要思考当前鼠标焦点在哪

### 1.2 更便捷地输入中文
pyperclip库（剪贴板）
```python
a = "我喜欢python"  
pyperclip.copy(a)  
mouse.hotkey("ctrl", "v")
```
